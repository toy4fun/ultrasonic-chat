<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultrasonic Data Transfer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0a0e17;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .container {
    width: 100%;
    max-width: 600px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    flex: 1;
  }

  header {
    text-align: center;
    padding: 12px 0;
  }

  header h1 {
    font-size: 1.4em;
    color: #00d4ff;
    letter-spacing: 1px;
  }

  .status-bar {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 6px;
    font-size: 0.85em;
  }

  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #555;
    transition: background 0.3s;
  }

  .status-dot.listening { background: #00ff88; box-shadow: 0 0 6px #00ff88; }
  .status-dot.sending { background: #ff8800; box-shadow: 0 0 6px #ff8800; }

  .visualizer-wrapper {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 8px;
  }

  canvas {
    width: 100%;
    height: 100px;
    display: block;
    border-radius: 4px;
  }

  .freq-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.65em;
    color: #667;
    padding: 2px 4px 0;
  }

  .messages {
    flex: 1;
    min-height: 180px;
    max-height: 40vh;
    overflow-y: auto;
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .messages:empty::before {
    content: 'No messages yet. Start listening and send a message from another device.';
    color: #445;
    font-style: italic;
    font-size: 0.85em;
  }

  .msg {
    padding: 8px 12px;
    border-radius: 8px;
    max-width: 85%;
    word-break: break-word;
    font-size: 0.9em;
    line-height: 1.4;
  }

  .msg.sent {
    background: #1a3a5c;
    align-self: flex-end;
    border-bottom-right-radius: 2px;
  }

  .msg.received {
    background: #1c2a1c;
    align-self: flex-start;
    border-bottom-left-radius: 2px;
  }

  .msg .meta {
    font-size: 0.7em;
    color: #667;
    margin-top: 4px;
  }

  .msg .meta.acked { color: #00ff88; }
  .msg .meta.no-ack { color: #ff4466; }

  .send-area {
    display: flex;
    gap: 8px;
  }

  .send-area input {
    flex: 1;
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid #1e293b;
    background: #111827;
    color: #e0e0e0;
    font-size: 0.95em;
    outline: none;
  }

  .send-area input:focus { border-color: #00d4ff; }

  button {
    padding: 10px 18px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 600;
    transition: background 0.2s, opacity 0.2s;
  }

  button:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-send {
    background: #00d4ff;
    color: #0a0e17;
  }

  .btn-send:hover:not(:disabled) { background: #00b8e0; }

  .controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .btn-listen {
    background: #00ff88;
    color: #0a0e17;
  }

  .btn-listen:hover:not(:disabled) { background: #00dd77; }

  .btn-stop {
    background: #ff4466;
    color: #fff;
  }

  .btn-stop:hover:not(:disabled) { background: #dd3355; }

  .btn-file {
    background: #9b59b6;
    color: #fff;
  }

  .btn-file:hover:not(:disabled) { background: #8e44ad; }

  .msg .file-link {
    display: inline-block;
    margin-top: 4px;
    padding: 4px 10px;
    background: #2a4a6b;
    border-radius: 4px;
    color: #00d4ff;
    text-decoration: none;
    font-size: 0.85em;
  }

  .msg .file-link:hover { background: #345a7e; }

  .debug-log {
    font-size: 0.7em;
    color: #556;
    max-height: 60px;
    overflow-y: auto;
    padding: 4px 8px;
    background: #0d1117;
    border-radius: 4px;
    border: 1px solid #1e293b;
  }

  .freq-select {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 0.8em;
  }

  .freq-select select {
    padding: 4px 8px;
    border-radius: 6px;
    border: 1px solid #1e293b;
    background: #111827;
    color: #e0e0e0;
    font-size: 0.95em;
    outline: none;
  }

  .freq-select select:focus { border-color: #00d4ff; }

  .freq-select .freq-warn {
    color: #ff8800;
    font-size: 0.85em;
  }

  .speed-panel {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 10px 14px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .speed-panel .speed-box {
    text-align: center;
  }

  .speed-panel .speed-label {
    font-size: 0.7em;
    color: #667;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .speed-panel .speed-value {
    font-size: 1.3em;
    font-weight: 700;
    font-family: 'Courier New', monospace;
    margin-top: 2px;
  }

  .speed-panel .speed-value.tx { color: #ff8800; }
  .speed-panel .speed-value.rx { color: #00ff88; }

  .speed-panel .speed-detail {
    font-size: 0.65em;
    color: #556;
    margin-top: 2px;
  }

  .progress-wrapper {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 8px 12px;
    display: none;
  }

  .progress-wrapper.visible { display: block; }

  .progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .progress-label {
    font-size: 0.8em;
    font-weight: 600;
    color: #e0e0e0;
  }

  .progress-detail {
    font-size: 0.75em;
    color: #889;
    font-family: 'Courier New', monospace;
  }

  .progress-track {
    width: 100%;
    height: 6px;
    background: #1e293b;
    border-radius: 3px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    width: 0%;
    border-radius: 3px;
    transition: width 0.15s ease;
  }

  .progress-fill.tx { background: linear-gradient(90deg, #ff8800, #ffaa44); }
  .progress-fill.rx { background: linear-gradient(90deg, #00ff88, #44ffaa); }
  .progress-fill.rx-pulse {
    background: linear-gradient(90deg, #00ff88, #44ffaa);
    animation: pulse-rx 1.2s ease-in-out infinite;
  }

  @keyframes pulse-rx {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Ultrasonic Transfer</h1>
    <div class="status-bar">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Idle</span>
    </div>
  </header>

  <div class="freq-select">
    <label for="bandSelect">Band:</label>
    <select id="bandSelect">
      <option value="8000">8 kHz (Audible, reliable)</option>
      <option value="12000">12 kHz (Balanced)</option>
      <option value="16000" selected>16 kHz (Mostly inaudible)</option>
      <option value="18000">18 kHz (Ultra-high)</option>
    </select>
    <label for="carrierSelect">Carriers:</label>
    <select id="carrierSelect">
      <option value="2">2 DQPSK (~25 B/s)</option>
      <option value="4" selected>4 DQPSK (~50 B/s)</option>
      <option value="8">8 DQPSK (~100 B/s)</option>
    </select>
    <span class="freq-warn">All devices must match!</span>
  </div>

  <div class="progress-wrapper" id="progressWrapper">
    <div class="progress-header">
      <span class="progress-label" id="progressLabel">Sending...</span>
      <span class="progress-detail" id="progressDetail">0%</span>
    </div>
    <div class="progress-track">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="visualizer-wrapper">
    <canvas id="spectrum"></canvas>
    <div class="freq-labels" id="freqLabels">
      <span>15.2 kHz</span>
      <span>4 DQPSK carriers</span>
      <span>17.2 kHz</span>
    </div>
  </div>

  <div class="messages" id="messages"></div>

  <div class="send-area">
    <input type="text" id="msgInput" placeholder="Type a message..." maxlength="200" />
    <button class="btn-send" id="btnSend">Send</button>
    <button class="btn-file" id="btnFile">File</button>
    <input type="file" id="fileInput" style="display:none" />
  </div>

  <div class="controls">
    <button class="btn-listen" id="btnListen">Start Listening</button>
    <button class="btn-stop" id="btnStop" disabled>Stop</button>
  </div>

  <div class="speed-panel">
    <div class="speed-box">
      <div class="speed-label">TX Speed</div>
      <div class="speed-value tx" id="txSpeed">-- KB/s</div>
      <div class="speed-detail" id="txDetail">No data sent yet</div>
    </div>
    <div class="speed-box">
      <div class="speed-label">RX Speed</div>
      <div class="speed-value rx" id="rxSpeed">-- KB/s</div>
      <div class="speed-detail" id="rxDetail">No data received yet</div>
    </div>
  </div>

  <div class="debug-log" id="debugLog"></div>
</div>

<script>
(function() {
  'use strict';

  // ══════════════════════════════════════════════════════════════════
  // DQPSK MODULATION
  //
  // Data is encoded as phase *changes* on parallel carriers.
  // Each symbol period, every carrier shifts its phase by one of
  // 4 values encoding a 2-bit dibit:
  //   00 → +0°    01 → +90°    10 → +180°    11 → +270°
  //
  // Frequency layout (relative to bandBase):
  //   Markers (below carriers):
  //     base - 800  (START)
  //     base - 600  (STOP)
  //     base - 400  (ACK)
  //   Carriers: base, base+400, base+800, ... base+(N-1)*400
  //
  // Markers are placed BELOW the carrier band so they stay in a
  // frequency range that speakers/mics can handle. At 16 kHz base:
  //   Markers: 15200–15600 Hz, Carriers: 16000–18800 Hz (8 carriers)
  // Total bandwidth: ~4 kHz
  //
  // Data rate:  numCarriers * 2 bits / SYMBOL_MS
  //   4 carriers @ 20ms → 400 bits/s = 50 bytes/s
  //   8 carriers @ 20ms → 800 bits/s = 100 bytes/s
  // ══════════════════════════════════════════════════════════════════

  const CARRIER_SPACING = 400;   // Hz between adjacent carriers
  const MAX_CARRIERS    = 8;     // max supported carrier count
  const SYMBOL_MS       = 20;    // ms per DQPSK symbol
  const MARKER_MS       = 100;   // ms for START/STOP/ACK tones
  const GAP_MS          = 50;    // ms silence after START / before STOP
  const SAMPLE_RATE     = 44100;
  const FFT_SIZE        = 4096;  // AnalyserNode fftSize (visualization + RX)

  // Phase offsets for DQPSK dibits
  const DIBIT_PHASE = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];

  let bandBase    = 16000;
  let numCarriers = 4;

  // Derived frequencies (recomputed by applyBand/recomputeFreqs)
  let carrierFreqs = [];
  let FREQ_START, FREQ_STOP, FREQ_ACK;

  function applyBand(base) {
    bandBase = base;
    recomputeFreqs();
  }

  function recomputeFreqs() {
    carrierFreqs = [];
    for (let i = 0; i < numCarriers; i++) {
      carrierFreqs.push(bandBase + i * CARRIER_SPACING);
    }
    // Markers sit BELOW the carrier band — reliable on all hardware
    FREQ_START = bandBase - 800;
    FREQ_STOP  = bandBase - 600;
    FREQ_ACK   = bandBase - 400;

    updateFreqLabels();
  }

  function updateFreqLabels() {
    const labels = document.getElementById('freqLabels');
    if (!labels) return;
    const lo = (FREQ_START / 1000).toFixed(1);
    const hiCarrier = (carrierFreqs[numCarriers - 1] / 1000).toFixed(1);
    labels.children[0].textContent = lo + ' kHz';
    labels.children[1].textContent = numCarriers + ' DQPSK carriers';
    labels.children[2].textContent = hiCarrier + ' kHz';
  }

  recomputeFreqs();

  // ── DOM Elements ──
  const statusDot  = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const messagesEl = document.getElementById('messages');
  const msgInput   = document.getElementById('msgInput');
  const btnSend    = document.getElementById('btnSend');
  const btnListen  = document.getElementById('btnListen');
  const btnStop    = document.getElementById('btnStop');
  const canvas     = document.getElementById('spectrum');
  const debugLog   = document.getElementById('debugLog');
  const txSpeedEl  = document.getElementById('txSpeed');
  const txDetailEl = document.getElementById('txDetail');
  const rxSpeedEl  = document.getElementById('rxSpeed');
  const rxDetailEl = document.getElementById('rxDetail');
  const ctx        = canvas.getContext('2d');

  const progressWrapper = document.getElementById('progressWrapper');
  const progressLabel   = document.getElementById('progressLabel');
  const progressDetail  = document.getElementById('progressDetail');
  const progressFill    = document.getElementById('progressFill');

  function showProgress(label, mode) {
    progressWrapper.classList.add('visible');
    progressLabel.textContent = label;
    progressDetail.textContent = '0%';
    progressFill.style.width = '0%';
    progressFill.className = 'progress-fill ' + (mode || 'tx');
  }

  function updateProgress(pct, detail) {
    progressFill.style.width = Math.min(100, pct).toFixed(1) + '%';
    progressDetail.textContent = detail || (Math.round(pct) + '%');
  }

  function hideProgress() {
    progressWrapper.classList.remove('visible');
  }

  // ── State ──
  let audioCtx       = null;
  let analyser       = null;
  let micStream      = null;
  let micSource      = null;
  let isListening    = false;
  let isSending      = false;
  let animFrameId    = null;
  let timeDomainBuf  = null; // Float32Array for AnalyserNode time-domain data
  let lastPollTime   = 0;    // timestamp of last pollSpectrum call

  // RX state machine
  const RX_IDLE      = 0;
  const RX_SYNC      = 1;  // waiting through post-START silence
  const RX_REFERENCE = 2;  // capturing reference symbol phases
  const RX_DATA      = 3;  // decoding data symbols
  let rxState        = RX_IDLE;

  // RX sample accumulation
  let rxSampleBuf    = new Float32Array(0);
  let rxSampleCount  = 0;

  // RX DQPSK state
  let prevPhases     = [];   // reference phases per carrier
  let rxDibits       = [];   // accumulated received dibits
  let rxStartTime    = 0;
  let symbolSamples  = 0;    // samples per symbol (computed from actual sample rate)
  let gapSamples     = 0;    // samples for the sync gap
  let markerSamples  = 0;    // samples for a marker tone

  // Goertzel energy tracking for marker detection in IDLE
  let markerDetectCount = 0;
  const MARKER_CONFIRM  = 2; // consecutive Goertzel hits to confirm marker
  let idleLogTimer      = 0; // throttle diagnostic logging in IDLE
  let rxCallbackCount   = 0; // heartbeat counter for ScriptProcessorNode

  // For visualizer overlay
  let rxStateLabel   = 'IDLE';
  let lastDibitStr   = '';
  let rxSyncEnterSampleCount = 0; // samples consumed in SYNC state

  // Speed measurement state
  // (rxStartTime declared above)

  // ACK state
  let waitingForAck  = false;
  let ackTimeout     = null;
  let lastSentMsgEl  = null;
  let ackCount       = 0;

  // ── Helpers ──
  function log(msg) {
    const line = document.createElement('div');
    line.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg;
    debugLog.appendChild(line);
    debugLog.scrollTop = debugLog.scrollHeight;
  }

  function setStatus(text, mode) {
    statusText.textContent = text;
    statusDot.className = 'status-dot' + (mode ? ' ' + mode : '');
  }

  function addMessage(text, type) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    const body = document.createElement('div');
    body.textContent = text;
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = (type === 'sent' ? 'Sent' : 'Received') + ' at ' +
      new Date().toLocaleTimeString();
    div.appendChild(body);
    div.appendChild(meta);
    messagesEl.appendChild(div);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    return div;
  }

  function formatSpeed(bytes, ms) {
    const seconds = ms / 1000;
    const kbSec = (bytes / 1024) / seconds;
    const bSec = bytes / seconds;
    if (kbSec >= 0.01) {
      return { display: kbSec.toFixed(3) + ' KB/s', detail: bytes + ' B in ' + seconds.toFixed(2) + 's (' + bSec.toFixed(1) + ' B/s)' };
    }
    return { display: bSec.toFixed(1) + ' B/s', detail: bytes + ' B in ' + seconds.toFixed(2) + 's' };
  }

  function crc8(bytes) {
    let crc = 0;
    for (let i = 0; i < bytes.length; i++) {
      crc ^= bytes[i];
      for (let j = 0; j < 8; j++) {
        crc = (crc & 0x80) ? ((crc << 1) ^ 0x07) & 0xFF : (crc << 1) & 0xFF;
      }
    }
    return crc;
  }

  function freqToBin(freq, fftSize, sampleRate) {
    return Math.round(freq / (sampleRate / fftSize));
  }

  function binToFreq(bin, fftSize, sampleRate) {
    return bin * (sampleRate / fftSize);
  }

  // ── Audio Context Init ──
  function ensureAudioCtx() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    return audioCtx;
  }

  // ══════════════════════════════════════════════════════════════════
  // TX PIPELINE — pre-computed DQPSK waveform
  // ══════════════════════════════════════════════════════════════════

  function generateDQPSKWaveform(bytes, sr) {
    const nc = numCarriers;

    // Convert bytes to bit stream, then to dibits (2 bits each)
    const dibits = [];
    for (let i = 0; i < bytes.length; i++) {
      dibits.push((bytes[i] >> 6) & 0x03);
      dibits.push((bytes[i] >> 4) & 0x03);
      dibits.push((bytes[i] >> 2) & 0x03);
      dibits.push(bytes[i] & 0x03);
    }
    // Pad to multiple of numCarriers
    while (dibits.length % nc !== 0) dibits.push(0);

    const numSymbols = dibits.length / nc;
    const symSamples = Math.round(sr * SYMBOL_MS / 1000);
    const mrkSamples = Math.round(sr * MARKER_MS / 1000);
    const gapSamp    = Math.round(sr * GAP_MS / 1000);
    const postGap    = Math.round(sr * 20 / 1000); // short gap before STOP

    // Reference symbol is 3x symbol duration for timing margin
    const refSamples = symSamples * 3;
    // Total length: START + gap + reference + data symbols + gap + STOP
    const totalSamples = mrkSamples + gapSamp + refSamples + (numSymbols * symSamples) + postGap + mrkSamples;
    const waveform = new Float32Array(totalSamples);

    let pos = 0;
    const TWO_PI = 2 * Math.PI;

    // Helper: write a single-frequency tone into waveform at position
    function writeTone(freq, samples, amplitude) {
      for (let s = 0; s < samples; s++) {
        // Soft envelope: 2ms ramp at edges
        const rampSamples = Math.round(sr * 0.002);
        let env = 1.0;
        if (s < rampSamples) env = s / rampSamples;
        else if (s > samples - rampSamples) env = (samples - s) / rampSamples;
        waveform[pos + s] += amplitude * env * Math.sin(TWO_PI * freq * s / sr);
      }
    }

    // 1. START marker
    writeTone(FREQ_START, mrkSamples, 0.7);
    pos += mrkSamples;

    // 2. Silence gap
    pos += gapSamp;

    // 3. Reference symbol — all carriers at phase 0 (no data, establishes reference)
    const amp = 0.7 / nc; // amplitude per carrier
    const phaseAccum = new Float64Array(nc); // accumulated phase per carrier (radians)
    const carrierPhasePerSample = new Float64Array(nc);
    for (let c = 0; c < nc; c++) {
      carrierPhasePerSample[c] = TWO_PI * carrierFreqs[c] / sr;
    }

    // Write reference symbol (3x symbol duration for timing margin)
    for (let s = 0; s < refSamples; s++) {
      let sample = 0;
      const rampSamples = Math.min(Math.round(sr * 0.001), Math.floor(refSamples / 4));
      let env = 1.0;
      if (s < rampSamples) env = s / rampSamples;
      else if (s > refSamples - rampSamples) env = (refSamples - s) / rampSamples;
      for (let c = 0; c < nc; c++) {
        sample += amp * env * Math.sin(phaseAccum[c]);
        phaseAccum[c] += carrierPhasePerSample[c];
      }
      waveform[pos + s] = sample;
    }
    pos += refSamples;

    // 4. Data symbols
    for (let sym = 0; sym < numSymbols; sym++) {
      // Apply phase jumps for this symbol's dibits
      for (let c = 0; c < nc; c++) {
        const dibit = dibits[sym * nc + c];
        phaseAccum[c] += DIBIT_PHASE[dibit];
      }

      for (let s = 0; s < symSamples; s++) {
        let sample = 0;
        const rampSamples = Math.min(Math.round(sr * 0.001), Math.floor(symSamples / 4));
        let env = 1.0;
        if (s < rampSamples) env = s / rampSamples;
        else if (s > symSamples - rampSamples) env = (symSamples - s) / rampSamples;
        for (let c = 0; c < nc; c++) {
          sample += amp * env * Math.sin(phaseAccum[c]);
          phaseAccum[c] += carrierPhasePerSample[c];
        }
        waveform[pos + s] = sample;
      }
      pos += symSamples;
    }

    // 5. Short gap before STOP
    pos += postGap;

    // 6. STOP marker
    writeTone(FREQ_STOP, mrkSamples, 0.7);
    pos += mrkSamples;

    return { waveform, numSymbols, symSamples };
  }

  function playWaveform(float32Array) {
    return new Promise(resolve => {
      const actx = ensureAudioCtx();
      const buffer = actx.createBuffer(1, float32Array.length, actx.sampleRate);
      buffer.getChannelData(0).set(float32Array);
      const source = actx.createBufferSource();
      source.buffer = buffer;
      source.connect(actx.destination);
      source.onended = resolve;
      source.start();
    });
  }

  function playTone(freq, durationMs) {
    return new Promise(resolve => {
      const actx = ensureAudioCtx();
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, actx.currentTime);
      gain.gain.setValueAtTime(0, actx.currentTime);
      gain.gain.linearRampToValueAtTime(0.7, actx.currentTime + 0.005);
      gain.gain.setValueAtTime(0.7, actx.currentTime + durationMs / 1000 - 0.005);
      gain.gain.linearRampToValueAtTime(0, actx.currentTime + durationMs / 1000);
      osc.connect(gain);
      gain.connect(actx.destination);
      osc.start(actx.currentTime);
      osc.stop(actx.currentTime + durationMs / 1000 + 0.01);
      setTimeout(resolve, durationMs);
    });
  }

  function silence(durationMs) {
    return new Promise(resolve => setTimeout(resolve, durationMs));
  }

  // ── Shared DQPSK transmitter ──
  async function transmitBytes(bytes) {
    const nc = numCarriers;
    const hash = crc8(bytes);
    log('TX: CRC-8 = 0x' + hash.toString(16).toUpperCase().padStart(2, '0') +
        ' (' + (bytes.length + 1) + ' bytes, ' + nc + '-carrier DQPSK)');

    // Append CRC byte
    const allBytes = new Uint8Array(bytes.length + 1);
    allBytes.set(bytes);
    allBytes[bytes.length] = hash;

    const sr = ensureAudioCtx().sampleRate;
    const { waveform, numSymbols } = generateDQPSKWaveform(allBytes, sr);

    showProgress('Sending...', 'tx');
    updateProgress(0, '0 / ' + numSymbols + ' symbols');

    // Play the entire waveform at once
    // Update progress periodically during playback
    const totalMs = (waveform.length / sr) * 1000;
    const startTime = performance.now();

    const progressInterval = setInterval(() => {
      const elapsed = performance.now() - startTime;
      const pct = Math.min(100, (elapsed / totalMs) * 100);
      const symsDone = Math.min(numSymbols, Math.floor((pct / 100) * numSymbols));
      updateProgress(pct, symsDone + ' / ' + numSymbols + ' symbols');
    }, 50);

    await playWaveform(waveform);

    clearInterval(progressInterval);
    updateProgress(100, 'Done');
    hideProgress();

    return bytes.length;
  }

  function waitForAck(msgEl) {
    if (!isListening) return;
    waitingForAck = true;
    ackCount = 0;
    lastSentMsgEl = msgEl;
    msgEl.querySelector('.meta').textContent += ' — awaiting ACK...';
    setStatus('Waiting for ACK...', 'sending');
    log('TX: Waiting for ACKs...');
    ackTimeout = setTimeout(() => {
      waitingForAck = false;
      if (lastSentMsgEl) {
        const meta = lastSentMsgEl.querySelector('.meta');
        if (ackCount === 0) {
          meta.textContent = meta.textContent.replace(/ — awaiting ACK\.\.\.$/, '') + ' — NO ACK';
          meta.classList.add('no-ack');
        }
        lastSentMsgEl = null;
      }
      log('TX: ACK window closed — ' + ackCount + ' receiver(s) confirmed');
      setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
    }, 5000);
  }

  async function transmitMessage(text) {
    if (isSending) return;
    isSending = true;
    btnSend.disabled = true;
    setStatus('Sending...', 'sending');
    log('TX: "' + text + '"');

    try {
      const txStart = performance.now();
      const encoder = new TextEncoder();
      const textBytes = encoder.encode(text);
      const bytes = new Uint8Array(1 + textBytes.length);
      bytes[0] = 0x00;
      bytes.set(textBytes, 1);

      const byteCount = await transmitBytes(bytes);

      const txElapsed = performance.now() - txStart;
      const speed = formatSpeed(byteCount, txElapsed);
      txSpeedEl.textContent = speed.display;
      txDetailEl.textContent = speed.detail;

      const msgEl = addMessage(text, 'sent');
      log('TX complete — ' + speed.detail);
      waitForAck(msgEl);
    } catch (e) {
      log('TX error: ' + e.message);
    }

    isSending = false;
    btnSend.disabled = false;
    if (!waitingForAck) {
      setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
    }
  }

  // ── File Transmission ──
  const MAX_FILE_SIZE = 1024;

  async function transmitFile(file) {
    if (isSending) return;

    if (file.size > MAX_FILE_SIZE) {
      log('TX: File too large (' + file.size + ' bytes, max ' + MAX_FILE_SIZE + ')');
      alert('File too large. Maximum size is ' + MAX_FILE_SIZE + ' bytes.');
      return;
    }

    isSending = true;
    btnSend.disabled = true;
    document.getElementById('btnFile').disabled = true;
    setStatus('Sending file...', 'sending');
    log('TX: file "' + file.name + '" (' + file.size + ' bytes)');

    try {
      const txStart = performance.now();
      const fileData = new Uint8Array(await file.arrayBuffer());
      const encoder = new TextEncoder();
      const nameBytes = encoder.encode(file.name);
      const nameLen = Math.min(nameBytes.length, 255);

      const bytes = new Uint8Array(1 + 1 + nameLen + fileData.length);
      bytes[0] = 0x01;
      bytes[1] = nameLen;
      bytes.set(nameBytes.subarray(0, nameLen), 2);
      bytes.set(fileData, 2 + nameLen);

      const byteCount = await transmitBytes(bytes);

      const txElapsed = performance.now() - txStart;
      const speed = formatSpeed(byteCount, txElapsed);
      txSpeedEl.textContent = speed.display;
      txDetailEl.textContent = speed.detail;

      const msgEl = addMessage('File: ' + file.name + ' (' + file.size + ' B)', 'sent');
      log('TX file complete — ' + speed.detail);
      waitForAck(msgEl);
    } catch (e) {
      log('TX file error: ' + e.message);
    }

    isSending = false;
    document.getElementById('btnFile').disabled = false;
    btnSend.disabled = false;
    if (!waitingForAck) {
      setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
    }
  }

  function addFileMessage(fileName, fileData, type, crcOk) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    const body = document.createElement('div');
    body.textContent = 'File: ' + fileName + ' (' + fileData.length + ' B)';
    div.appendChild(body);
    if (type === 'received') {
      const blob = new Blob([fileData]);
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.className = 'file-link';
      link.href = url;
      link.download = fileName;
      link.textContent = 'Download ' + fileName;
      div.appendChild(link);
    }
    const meta = document.createElement('div');
    meta.className = 'meta';
    if (crcOk === false) meta.classList.add('no-ack');
    meta.textContent = (type === 'sent' ? 'Sent' : 'Received') + ' at ' +
      new Date().toLocaleTimeString() + (crcOk === false ? ' — CRC FAIL' : '');
    div.appendChild(meta);
    messagesEl.appendChild(div);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    return div;
  }

  // ══════════════════════════════════════════════════════════════════
  // RX PIPELINE — ScriptProcessorNode + I/Q correlator
  // ══════════════════════════════════════════════════════════════════

  // Goertzel filter: returns magnitude^2 for a single target frequency
  function goertzel(samples, offset, length, targetFreq, sr) {
    const k = Math.round(length * targetFreq / sr);
    const w = 2 * Math.PI * k / length;
    const cosw = Math.cos(w);
    const coeff = 2 * cosw;
    let s0 = 0, s1 = 0, s2 = 0;
    for (let i = 0; i < length; i++) {
      s0 = samples[offset + i] + coeff * s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    // Return magnitude (not magnitude^2) normalized by length
    const real = s1 - s2 * cosw;
    const imag = s2 * Math.sin(w);
    return Math.sqrt(real * real + imag * imag) / length;
  }

  // I/Q correlator: returns phase angle of a carrier in a sample window
  function measurePhase(samples, offset, length, carrierFreq, sr) {
    let sumI = 0, sumQ = 0;
    const TWO_PI = 2 * Math.PI;
    for (let i = 0; i < length; i++) {
      const t = i / sr;
      sumI += samples[offset + i] * Math.cos(TWO_PI * carrierFreq * t);
      sumQ += samples[offset + i] * Math.sin(TWO_PI * carrierFreq * t);
    }
    return Math.atan2(sumQ, sumI);
  }

  // Normalize angle to [0, 2*PI)
  function normAngle(a) {
    a = a % (2 * Math.PI);
    if (a < 0) a += 2 * Math.PI;
    return a;
  }

  // Map a phase difference to the nearest dibit
  function phaseDiffToDibit(diff) {
    diff = normAngle(diff);
    // Decision boundaries at pi/4, 3pi/4, 5pi/4, 7pi/4
    if (diff < Math.PI / 4 || diff >= 7 * Math.PI / 4) return 0; // ~0°
    if (diff < 3 * Math.PI / 4) return 1;                         // ~90°
    if (diff < 5 * Math.PI / 4) return 2;                         // ~180°
    return 3;                                                      // ~270°
  }

  // Check if a marker tone is present in a sample block.
  // Uses adaptive threshold: marker must be > absolute floor AND
  // significantly above the average energy of non-marker frequencies.
  function detectMarker(samples, offset, length, sr) {
    const floor = 0.0005; // absolute minimum magnitude
    const startMag = goertzel(samples, offset, length, FREQ_START, sr);
    const stopMag  = goertzel(samples, offset, length, FREQ_STOP, sr);
    const ackMag   = goertzel(samples, offset, length, FREQ_ACK, sr);

    // Measure noise floor from frequencies well outside marker AND carrier bands
    const noiseMag1 = goertzel(samples, offset, length, FREQ_START - 500, sr);
    const noiseMag2 = goertzel(samples, offset, length, FREQ_START - 700, sr);
    const noiseFloor = (noiseMag1 + noiseMag2) / 2;
    const threshold = Math.max(floor, noiseFloor * 2);

    if (startMag > threshold && startMag > stopMag && startMag > ackMag) return { type: 'START', mag: startMag, thr: threshold };
    if (stopMag > threshold && stopMag > startMag && stopMag > ackMag) return { type: 'STOP', mag: stopMag, thr: threshold };
    if (ackMag > threshold && ackMag > startMag && ackMag > stopMag) return { type: 'ACK', mag: ackMag, thr: threshold };
    return null;
  }

  // Check if carriers are present (energy on carrier frequencies)
  function carriersPresent(samples, offset, length, sr) {
    const floor = 0.0003;
    let totalMag = 0;
    for (let c = 0; c < numCarriers; c++) {
      totalMag += goertzel(samples, offset, length, carrierFreqs[c], sr);
    }
    // Average carrier magnitude must exceed floor
    return (totalMag / numCarriers) > floor;
  }

  // Main RX sample processor — fed from pollSpectrum via AnalyserNode
  function feedRxSamples(newSamples, count) {
    if (!isListening) return;
    if (count <= 0) return;
    const sr = audioCtx.sampleRate;

    // Heartbeat logging
    rxCallbackCount++;
    if (rxCallbackCount === 1) {
      log('RX: pipeline active, sr=' + sr +
          ' freqs: START=' + FREQ_START + ' STOP=' + FREQ_STOP + ' ACK=' + FREQ_ACK +
          ' carriers=[' + carrierFreqs.join(',') + ']');
    }
    if (rxCallbackCount % 120 === 0) {
      let peak = 0;
      for (let i = 0; i < count; i++) {
        const abs = Math.abs(newSamples[i]);
        if (abs > peak) peak = abs;
      }
      log('RX heartbeat: state=' + rxStateLabel + ' buf=' + rxSampleCount +
          ' fed=' + count + ' peak=' + peak.toFixed(5));
    }

    // Append new samples to accumulation buffer
    if (rxSampleCount + count > rxSampleBuf.length) {
      const newSize = Math.max(rxSampleCount + count, rxSampleBuf.length * 2, sr * 2);
      const newBuf = new Float32Array(newSize);
      if (rxSampleCount > 0) newBuf.set(rxSampleBuf.subarray(0, rxSampleCount));
      rxSampleBuf = newBuf;
    }
    // Copy only 'count' samples (newSamples may be larger buffer)
    for (let i = 0; i < count; i++) {
      rxSampleBuf[rxSampleCount + i] = newSamples[i];
    }
    rxSampleCount += count;

    // Precompute timing in samples
    symbolSamples = Math.round(sr * SYMBOL_MS / 1000);
    gapSamples    = Math.round(sr * GAP_MS / 1000);
    markerSamples = Math.round(sr * MARKER_MS / 1000);

    const analysisBlock = Math.round(sr * 0.02); // 20ms blocks for Goertzel

    switch (rxState) {
      case RX_IDLE:
        processIdle(sr, analysisBlock);
        break;
      case RX_SYNC:
        processSync(sr);
        break;
      case RX_REFERENCE:
        processReference(sr);
        break;
      case RX_DATA:
        processData(sr, analysisBlock);
        break;
    }

    // Prevent unbounded buffer growth in IDLE
    if (rxState === RX_IDLE && rxSampleCount > sr * 2) {
      const keep = Math.round(sr * 0.5);
      if (rxSampleCount > keep) {
        rxSampleBuf.copyWithin(0, rxSampleCount - keep, rxSampleCount);
        rxSampleCount = keep;
      }
    }
  }

  function processIdle(sr, blockSize) {
    // Process in overlapping blocks (50% overlap for better marker edge detection)
    const stride = Math.floor(blockSize / 2);
    while (rxSampleCount >= blockSize) {
      const result = detectMarker(rxSampleBuf, 0, blockSize, sr);
      const marker = result ? result.type : null;

      // Periodic diagnostic logging (every ~0.5s)
      const now = performance.now();
      if (now - idleLogTimer > 500) {
        idleLogTimer = now;
        // Always log magnitudes so we can see what the mic is picking up
        const s = goertzel(rxSampleBuf, 0, blockSize, FREQ_START, sr);
        const p = goertzel(rxSampleBuf, 0, blockSize, FREQ_STOP, sr);
        const a = goertzel(rxSampleBuf, 0, blockSize, FREQ_ACK, sr);
        // Also measure carrier energy
        let cMax = 0;
        for (let c = 0; c < numCarriers; c++) {
          const cm = goertzel(rxSampleBuf, 0, blockSize, carrierFreqs[c], sr);
          if (cm > cMax) cMax = cm;
        }
        const n1 = goertzel(rxSampleBuf, 0, blockSize, FREQ_START - 500, sr);
        const thr = result ? result.thr : Math.max(0.003, n1 * 3);
        log('RX idle: S=' + s.toFixed(5) + ' P=' + p.toFixed(5) + ' A=' + a.toFixed(5) +
            ' C=' + cMax.toFixed(5) + ' thr=' + thr.toFixed(5) +
            (result ? ' -> ' + result.type : '') +
            ' cnt=' + markerDetectCount);
      }

      if (marker === 'ACK') {
        if (waitingForAck) {
          ackCount++;
          if (lastSentMsgEl) {
            const meta = lastSentMsgEl.querySelector('.meta');
            meta.textContent = meta.textContent.replace(/ — awaiting ACK\.\.\.$| — ACK \(\d+\)$/, '')
              + ' — ACK (' + ackCount + ')';
            meta.classList.add('acked');
          }
          log('TX: ACK #' + ackCount + ' received (mag=' + result.mag.toFixed(4) + ')');
        }
        consumeSamples(blockSize);
        markerDetectCount = 0;
        continue;
      }

      if (marker === 'START') {
        markerDetectCount++;
        if (markerDetectCount >= MARKER_CONFIRM) {
          // START confirmed — transition to SYNC
          rxState = RX_SYNC;
          rxStateLabel = 'SYNC';
          rxDibits = [];
          prevPhases = [];
          rxStartTime = performance.now();
          rxSyncEnterSampleCount = 0;
          markerDetectCount = 0;
          log('RX: START detected (mag=' + result.mag.toFixed(4) + ' thr=' + result.thr.toFixed(4) + ')');
          setStatus('Receiving...', 'sending');
          showProgress('Receiving...', 'rx-pulse');
          updateProgress(0, '0 bytes');
          consumeSamples(blockSize);
          return;
        }
      } else {
        markerDetectCount = 0;
      }

      consumeSamples(stride); // advance by half-block for overlap
    }
  }

  function processSync(sr) {
    // Wait through the remainder of the START marker and the silence gap
    // until the reference symbol begins (carrier energy appears).
    //
    // TX structure: START(100ms) | GAP(50ms) | REF(60ms) | DATA...
    // START is detected ~30ms in, so ~70ms of marker + 50ms gap = ~120ms to skip.
    // The reference symbol is 3x symbol duration (60ms) so we have margin.
    //
    // Strategy: consume 5ms blocks while marker is present or silence.
    // When carriers appear WITHOUT marker → DON'T consume, transition to REF.
    const checkBlock = Math.round(sr * 0.005); // 5ms check blocks
    while (rxSampleCount >= checkBlock) {
      const startMag = goertzel(rxSampleBuf, 0, checkBlock, FREQ_START, sr);
      const isMarker = startMag > 0.0005;
      const hasCarriers = carriersPresent(rxSampleBuf, 0, checkBlock, sr);

      if (hasCarriers && !isMarker) {
        // Carriers detected, marker gone — we're at the reference symbol.
        // Do NOT consume this block — leave it for REFERENCE to use.
        rxState = RX_REFERENCE;
        rxStateLabel = 'REF';
        log('RX: SYNC complete after ' + (rxSyncEnterSampleCount / sr * 1000).toFixed(0) +
            'ms, carriers detected, starting reference capture');
        return;
      }

      // Still in marker or gap — consume and keep waiting
      rxSyncEnterSampleCount += checkBlock;
      consumeSamples(checkBlock);

      // Safety: if we've waited too long (>500ms), force transition
      if (rxSyncEnterSampleCount > sr * 0.5) {
        rxState = RX_REFERENCE;
        rxStateLabel = 'REF';
        log('RX: SYNC timeout after 500ms, forcing reference capture');
        return;
      }
    }
  }

  function processReference(sr) {
    // The TX reference symbol is 3x symbol duration (60ms).
    // We need 2x symbolSamples: skip the first (may be contaminated by
    // gap/marker tail), measure the second (clean reference).
    // The third symbolSamples provides margin before data starts.
    const needed = symbolSamples * 2;
    if (rxSampleCount >= needed) {
      // Skip first symbol period (possibly contaminated)
      // Measure phase from the second symbol period (clean)
      prevPhases = [];
      for (let c = 0; c < numCarriers; c++) {
        prevPhases.push(measurePhase(rxSampleBuf, symbolSamples, symbolSamples, carrierFreqs[c], sr));
      }
      // Consume 2 symbol periods. The 3rd period of the reference
      // will be consumed as the first "data" symbol in processData,
      // but since it has the same phase as the reference (no jump),
      // it will decode as dibit 00 for all carriers. We need to
      // skip this too — consume all 3 periods of the reference.
      const refTotal = symbolSamples * 3;
      if (rxSampleCount >= refTotal) {
        consumeSamples(refTotal);
      } else {
        consumeSamples(needed);
      }
      rxState = RX_DATA;
      rxStateLabel = 'DATA';
      log('RX: Reference captured (phases: ' +
          prevPhases.map(p => (p * 180 / Math.PI).toFixed(0) + '°').join(', ') + ')');
    }
  }

  let dataGapSamples = 0; // count consecutive silent samples in DATA state

  function processData(sr, blockSize) {
    // Process symbol-by-symbol
    while (rxSampleCount >= symbolSamples) {
      const checkLen = symbolSamples;

      // Check for STOP marker
      const markerResult = detectMarker(rxSampleBuf, 0, checkLen, sr);
      if (markerResult && markerResult.type === 'STOP') {
        log('RX: STOP detected after ' + rxDibits.length + ' dibits (mag=' + markerResult.mag.toFixed(4) + ')');
        consumeSamples(checkLen);
        dataGapSamples = 0;
        flushReceived();
        return;
      }

      // Check if carriers are present
      const hasCarriers = carriersPresent(rxSampleBuf, 0, checkLen, sr);

      if (!hasCarriers) {
        // No carrier energy — likely in pre-STOP gap or STOP marker
        dataGapSamples += checkLen;
        consumeSamples(checkLen);

        // Keep scanning for STOP in subsequent blocks
        const maxGapMs = 200; // max silence before force-flush
        if (dataGapSamples > sr * maxGapMs / 1000) {
          log('RX: silence timeout (' + maxGapMs + 'ms), flushing ' + rxDibits.length + ' dibits');
          dataGapSamples = 0;
          flushReceived();
          return;
        }
        continue; // keep consuming, looking for STOP
      }

      // Carriers present — decode a data symbol
      dataGapSamples = 0;

      const symbolDibits = [];
      const newPhases = [];
      for (let c = 0; c < numCarriers; c++) {
        const phase = measurePhase(rxSampleBuf, 0, symbolSamples, carrierFreqs[c], sr);
        const diff = phase - prevPhases[c];
        symbolDibits.push(phaseDiffToDibit(diff));
        newPhases.push(phase);
      }
      prevPhases = newPhases;

      for (let c = 0; c < numCarriers; c++) {
        rxDibits.push(symbolDibits[c]);
      }

      const rxBytesSoFar = Math.floor(rxDibits.length / 4);
      const rxPct = Math.min(95, rxBytesSoFar * 3);
      updateProgress(rxPct, rxBytesSoFar + ' bytes');
      lastDibitStr = symbolDibits.map(d => d.toString(2).padStart(2, '0')).join(' ');

      consumeSamples(symbolSamples);
    }
  }

  function consumeSamples(count) {
    if (count >= rxSampleCount) {
      rxSampleCount = 0;
    } else {
      // Shift remaining data to front (in-place, no allocation)
      rxSampleBuf.copyWithin(0, count, rxSampleCount);
      rxSampleCount -= count;
    }
  }

  function flushReceived() {
    rxState = RX_IDLE;
    rxStateLabel = 'IDLE';
    dataGapSamples = 0;
    setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
    updateProgress(100, 'Done');
    setTimeout(hideProgress, 600);

    log('RX: flush — ' + rxDibits.length + ' dibits received');

    // Convert dibits to bytes: 4 dibits = 8 bits = 1 byte
    const rxBytes = [];
    for (let i = 0; i + 3 < rxDibits.length; i += 4) {
      const b = (rxDibits[i] << 6) | (rxDibits[i + 1] << 4) | (rxDibits[i + 2] << 2) | rxDibits[i + 3];
      rxBytes.push(b);
    }

    // Need at least 1 data byte + 1 CRC byte
    if (rxBytes.length < 2) {
      log('RX: too few bytes (' + rxBytes.length + '), discarding');
      rxDibits = [];
      return;
    }

    // Last byte = CRC-8 hash, everything before = data
    const receivedHash = rxBytes[rxBytes.length - 1];
    const dataBytes = rxBytes.slice(0, -1);
    const computedHash = crc8(dataBytes);
    const hashMatch = (receivedHash === computedHash);

    if (hashMatch) {
      log('RX: CRC-8 verified (0x' + computedHash.toString(16).toUpperCase().padStart(2, '0') + ')');
    } else {
      log('RX: CRC-8 MISMATCH — received 0x' + receivedHash.toString(16).toUpperCase().padStart(2, '0') +
          ', computed 0x' + computedHash.toString(16).toUpperCase().padStart(2, '0'));
    }

    const rxElapsed = performance.now() - rxStartTime;
    const speed = formatSpeed(dataBytes.length, rxElapsed);
    rxSpeedEl.textContent = speed.display;
    rxDetailEl.textContent = speed.detail;

    const typeByte = dataBytes[0];
    log('RX: type=0x' + typeByte.toString(16).toUpperCase().padStart(2, '0') +
        ' dataLen=' + dataBytes.length + ' crc=' + (hashMatch ? 'OK' : 'FAIL'));

    try {
      if (typeByte === 0x01 && dataBytes.length >= 3) {
        const nameLen = dataBytes[1];
        log('RX: file branch — nameLen=' + nameLen + ' available=' + (dataBytes.length - 2));
        if (dataBytes.length < 2 + nameLen) {
          log('RX: file header truncated, showing as raw data');
          const rawData = new Uint8Array(dataBytes.slice(1));
          addFileMessage('corrupted_file.bin', rawData, 'received', false);
        } else {
          const decoder = new TextDecoder('utf-8', { fatal: false });
          const fileName = decoder.decode(new Uint8Array(dataBytes.slice(2, 2 + nameLen)));
          const fileData = new Uint8Array(dataBytes.slice(2 + nameLen));
          addFileMessage(fileName, fileData, 'received', hashMatch);
          log('RX: file "' + fileName + '" (' + fileData.length + ' B) — ' + speed.detail);
        }
      } else if (typeByte === 0x00 && dataBytes.length >= 2) {
        log('RX: text branch');
        const decoder = new TextDecoder('utf-8', { fatal: false });
        const text = decoder.decode(new Uint8Array(dataBytes.slice(1)));
        if (text.length > 0) {
          addMessage(text + (hashMatch ? '' : ' [CRC FAIL]'), 'received');
          log('RX: "' + text + '" — ' + speed.detail);
        }
      } else {
        log('RX: legacy branch');
        const decoder = new TextDecoder('utf-8', { fatal: false });
        const text = decoder.decode(new Uint8Array(dataBytes));
        if (text.length > 0) {
          addMessage(text + (hashMatch ? '' : ' [CRC FAIL]'), 'received');
          log('RX: (legacy) "' + text + '" — ' + speed.detail);
        }
      }
    } catch (e) {
      log('RX decode error: ' + e.message);
      addMessage('[Decode error: ' + e.message + ']', 'received');
    }

    rxDibits = [];

    if (hashMatch) {
      sendAck();
    }
  }

  async function sendAck() {
    const delay = 500 + Math.floor(Math.random() * 1500);
    log('RX: Sending ACK in ' + delay + 'ms...');
    await silence(delay);
    await playTone(FREQ_ACK, 300);
    log('RX: ACK sent');
  }

  // ── Microphone & Reception ──
  async function startListening() {
    try {
      ensureAudioCtx();

      micStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: SAMPLE_RATE
        }
      });

      micSource = audioCtx.createMediaStreamSource(micStream);

      // AnalyserNode for BOTH visualization AND RX sample extraction.
      // Use fftSize=4096 to get ~93ms of time-domain data per poll.
      // The RX pipeline is driven from pollSpectrum (requestAnimationFrame)
      // which extracts new samples from the AnalyserNode each frame.
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 4096;
      analyser.smoothingTimeConstant = 0.25;
      micSource.connect(analyser);

      timeDomainBuf = new Float32Array(analyser.fftSize);
      lastPollTime = performance.now();

      isListening = true;
      rxState = RX_IDLE;
      rxStateLabel = 'IDLE';
      rxDibits = [];
      rxSampleBuf = new Float32Array(0);
      rxSampleCount = 0;
      prevPhases = [];
      markerDetectCount = 0;
      dataGapSamples = 0;
      rxSyncEnterSampleCount = 0;
      idleLogTimer = 0;
      rxCallbackCount = 0;

      btnListen.disabled = true;
      btnStop.disabled = false;
      setStatus('Listening', 'listening');
      log('Listening started: DQPSK ' + numCarriers + ' carriers, sr=' + audioCtx.sampleRate +
          ', band=' + bandBase + 'Hz, START=' + FREQ_START + ' STOP=' + FREQ_STOP +
          ', carriers=[' + carrierFreqs.join(', ') + ']');

      pollSpectrum();
    } catch (e) {
      log('Mic error: ' + e.message);
      alert('Microphone access denied or unavailable.\n' + e.message);
    }
  }

  function stopListening() {
    isListening = false;
    waitingForAck = false;
    ackCount = 0;
    if (ackTimeout) { clearTimeout(ackTimeout); ackTimeout = null; }
    if (micSource) {
      micSource.disconnect();
      micSource = null;
    }
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if (animFrameId) {
      cancelAnimationFrame(animFrameId);
      animFrameId = null;
    }
    analyser = null;
    timeDomainBuf = null;
    rxState = RX_IDLE;
    rxStateLabel = 'IDLE';
    rxDibits = [];
    rxSampleBuf = new Float32Array(0);
    rxSampleCount = 0;
    dataGapSamples = 0;
    rxSyncEnterSampleCount = 0;

    btnListen.disabled = false;
    btnStop.disabled = true;
    setStatus('Idle', '');
    log('Listening stopped');
  }

  // ── Spectrum Visualizer + RX sample extraction ──
  // The AnalyserNode provides BOTH frequency data (for the visualizer)
  // and time-domain data (for the RX pipeline). We poll both in the
  // same requestAnimationFrame loop.
  //
  // getFloatTimeDomainData() returns the most recent fftSize samples.
  // Between frames (~16ms at 60fps), approximately sr*0.016 ≈ 706
  // new samples arrive. We estimate new samples from elapsed time
  // and take them from the END of the time-domain buffer (most recent).
  function pollSpectrum() {
    if (!isListening || !analyser) return;
    const sr = audioCtx.sampleRate;

    // ── Visualization ──
    const bufLen = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufLen);
    analyser.getByteFrequencyData(dataArray);
    drawSpectrum(dataArray, bufLen, sr);

    // ── RX sample extraction ──
    if (timeDomainBuf) {
      analyser.getFloatTimeDomainData(timeDomainBuf);

      const now = performance.now();
      const elapsedMs = Math.min(now - lastPollTime, 100); // cap at 100ms
      lastPollTime = now;

      // Estimate how many new samples arrived since last poll
      const newSampleCount = Math.min(
        Math.round(sr * elapsedMs / 1000),
        timeDomainBuf.length
      );

      if (newSampleCount > 0) {
        // New samples are at the END of the time-domain buffer
        const offset = timeDomainBuf.length - newSampleCount;
        feedRxSamples(timeDomainBuf.subarray(offset), newSampleCount);
      }
    }

    animFrameId = requestAnimationFrame(pollSpectrum);
  }

  function drawSpectrum(data, bufLen, sampleRate) {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.scale(dpr, dpr);
    }

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    // Display range: from markers (below carriers) to highest carrier + margin
    const freqLow  = FREQ_START - 400;
    const freqHigh = carrierFreqs[numCarriers - 1] + 400;
    const binLow   = Math.max(0, freqToBin(freqLow, FFT_SIZE, sampleRate));
    const binHigh  = Math.min(bufLen - 1, freqToBin(freqHigh, FFT_SIZE, sampleRate));
    const numBins  = binHigh - binLow + 1;
    const barW     = w / numBins;

    // Carrier hue rotation
    const carrierHues = [140, 200, 280, 50, 330, 30, 170, 100]; // up to 8

    for (let i = 0; i < numBins; i++) {
      const bin = binLow + i;
      if (bin < 0 || bin >= bufLen) continue;
      const val = data[bin] / 255;
      const barH = val * h;
      const freq = binToFreq(bin, FFT_SIZE, sampleRate);

      let color;
      let isCarrier = false;
      for (let c = 0; c < numCarriers; c++) {
        if (Math.abs(freq - carrierFreqs[c]) < CARRIER_SPACING * 0.4) {
          const hue = carrierHues[c % carrierHues.length];
          color = 'hsla(' + hue + ', 80%, ' + (30 + val * 40) + '%, ' + (0.4 + val * 0.6) + ')';
          isCarrier = true;
          break;
        }
      }

      if (!isCarrier) {
        // Check if it's in the marker range (markers are below carriers)
        const markerLo = FREQ_START - 100;
        const markerHi = FREQ_ACK + 100;
        if (freq >= markerLo && freq <= markerHi) {
          color = 'rgba(0, 150, 255, ' + (0.3 + val * 0.7) + ')';
        } else {
          color = 'rgba(50, 50, 80, ' + (0.2 + val * 0.3) + ')';
        }
      }

      ctx.fillStyle = color;
      ctx.fillRect(i * barW, h - barH, barW - 0.5, barH);
    }

    // Draw carrier frequency tick marks at bottom
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    for (let c = 0; c < numCarriers; c++) {
      const x = ((freqToBin(carrierFreqs[c], FFT_SIZE, sampleRate) - binLow) / numBins) * w;
      ctx.fillRect(x - 0.5, h - 3, 1, 3);
    }

    // Overlay: RX state and decoded dibit
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.font = '11px monospace';
    const overlayParts = [rxStateLabel];
    if (lastDibitStr && rxState === RX_DATA) overlayParts.push(lastDibitStr);
    ctx.fillText(overlayParts.join(' | '), 6, 14);
  }

  // ── Event Handlers ──
  const bandSelect = document.getElementById('bandSelect');
  bandSelect.addEventListener('change', () => {
    const base = parseInt(bandSelect.value, 10);
    applyBand(base);
    log('Band changed to ' + (base / 1000) + ' kHz base');
  });

  const carrierSelect = document.getElementById('carrierSelect');
  carrierSelect.addEventListener('change', () => {
    numCarriers = parseInt(carrierSelect.value, 10);
    recomputeFreqs();
    log('Carriers changed to ' + numCarriers);
  });

  btnSend.addEventListener('click', () => {
    const text = msgInput.value.trim();
    if (!text) return;
    msgInput.value = '';
    transmitMessage(text);
  });

  msgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') btnSend.click();
  });

  const btnFile   = document.getElementById('btnFile');
  const fileInput = document.getElementById('fileInput');

  btnFile.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (file) {
      transmitFile(file);
      fileInput.value = '';
    }
  });

  btnListen.addEventListener('click', startListening);
  btnStop.addEventListener('click', stopListening);

  // Draw empty canvas on load
  function drawEmpty() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#334';
    ctx.font = '12px monospace';
    ctx.fillText('Spectrum will appear when listening...', 10, h / 2);
  }

  drawEmpty();
  log('Ready (DQPSK mode). Click "Start Listening" to begin.');
})();
</script>
</body>
</html>
