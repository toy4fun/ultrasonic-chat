<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultrasonic Data Transfer</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0a0e17;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .container {
    width: 100%;
    max-width: 600px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    flex: 1;
  }

  header {
    text-align: center;
    padding: 12px 0;
  }

  header h1 {
    font-size: 1.4em;
    color: #00d4ff;
    letter-spacing: 1px;
  }

  .status-bar {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 6px;
    font-size: 0.85em;
  }

  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #555;
    transition: background 0.3s;
  }

  .status-dot.listening { background: #00ff88; box-shadow: 0 0 6px #00ff88; }
  .status-dot.sending { background: #ff8800; box-shadow: 0 0 6px #ff8800; }

  .visualizer-wrapper {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 8px;
  }

  canvas {
    width: 100%;
    height: 100px;
    display: block;
    border-radius: 4px;
  }

  .freq-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.65em;
    color: #667;
    padding: 2px 4px 0;
  }

  .messages {
    flex: 1;
    min-height: 180px;
    max-height: 40vh;
    overflow-y: auto;
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .messages:empty::before {
    content: 'No messages yet. Start listening and send a message from another device.';
    color: #445;
    font-style: italic;
    font-size: 0.85em;
  }

  .msg {
    padding: 8px 12px;
    border-radius: 8px;
    max-width: 85%;
    word-break: break-word;
    font-size: 0.9em;
    line-height: 1.4;
  }

  .msg.sent {
    background: #1a3a5c;
    align-self: flex-end;
    border-bottom-right-radius: 2px;
  }

  .msg.received {
    background: #1c2a1c;
    align-self: flex-start;
    border-bottom-left-radius: 2px;
  }

  .msg .meta {
    font-size: 0.7em;
    color: #667;
    margin-top: 4px;
  }

  .msg .meta.acked { color: #00ff88; }
  .msg .meta.no-ack { color: #ff4466; }

  .send-area {
    display: flex;
    gap: 8px;
  }

  .send-area input {
    flex: 1;
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid #1e293b;
    background: #111827;
    color: #e0e0e0;
    font-size: 0.95em;
    outline: none;
  }

  .send-area input:focus { border-color: #00d4ff; }

  button {
    padding: 10px 18px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 0.9em;
    font-weight: 600;
    transition: background 0.2s, opacity 0.2s;
  }

  button:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-send {
    background: #00d4ff;
    color: #0a0e17;
  }

  .btn-send:hover:not(:disabled) { background: #00b8e0; }

  .controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .btn-listen {
    background: #00ff88;
    color: #0a0e17;
  }

  .btn-listen:hover:not(:disabled) { background: #00dd77; }

  .btn-stop {
    background: #ff4466;
    color: #fff;
  }

  .btn-stop:hover:not(:disabled) { background: #dd3355; }

  .debug-log {
    font-size: 0.7em;
    color: #556;
    max-height: 60px;
    overflow-y: auto;
    padding: 4px 8px;
    background: #0d1117;
    border-radius: 4px;
    border: 1px solid #1e293b;
  }

  .speed-panel {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 8px;
    padding: 10px 14px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .speed-panel .speed-box {
    text-align: center;
  }

  .speed-panel .speed-label {
    font-size: 0.7em;
    color: #667;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .speed-panel .speed-value {
    font-size: 1.3em;
    font-weight: 700;
    font-family: 'Courier New', monospace;
    margin-top: 2px;
  }

  .speed-panel .speed-value.tx { color: #ff8800; }
  .speed-panel .speed-value.rx { color: #00ff88; }

  .speed-panel .speed-detail {
    font-size: 0.65em;
    color: #556;
    margin-top: 2px;
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Ultrasonic Transfer</h1>
    <div class="status-bar">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Idle</span>
    </div>
  </header>

  <div class="visualizer-wrapper">
    <canvas id="spectrum"></canvas>
    <div class="freq-labels">
      <span>Ch B: 16–17.5</span>
      <span>Markers</span>
      <span>Ch A: 18–19.5</span>
    </div>
  </div>

  <div class="messages" id="messages"></div>

  <div class="send-area">
    <input type="text" id="msgInput" placeholder="Type a message..." maxlength="200" />
    <button class="btn-send" id="btnSend">Send</button>
  </div>

  <div class="controls">
    <button class="btn-listen" id="btnListen">Start Listening</button>
    <button class="btn-stop" id="btnStop" disabled>Stop</button>
  </div>

  <div class="speed-panel">
    <div class="speed-box">
      <div class="speed-label">TX Speed</div>
      <div class="speed-value tx" id="txSpeed">-- KB/s</div>
      <div class="speed-detail" id="txDetail">No data sent yet</div>
    </div>
    <div class="speed-box">
      <div class="speed-label">RX Speed</div>
      <div class="speed-value rx" id="rxSpeed">-- KB/s</div>
      <div class="speed-detail" id="rxDetail">No data received yet</div>
    </div>
  </div>

  <div class="debug-log" id="debugLog"></div>
</div>

<script>
(function() {
  'use strict';

  // ── Frequency Map ──
  const FREQ_BASE_B = 16000; // Channel B (low nibble): 16000–17500 Hz
  const FREQ_ACK   = 17700;
  const FREQ_START = 17800;
  const FREQ_STOP  = 17900;
  const FREQ_BASE_A = 18000; // Channel A (high nibble): 18000–19500 Hz
  const FREQ_STEP   = 100;
  const NUM_NIBBLES = 16;

  const TONE_MS_MARKER  = 150;
  const TONE_MS_NIBBLE  = 100;
  const GAP_MS          = 60;

  const FFT_SIZE    = 2048;
  const SAMPLE_RATE = 44100;

  // Frequency tolerance for detection (Hz)
  const FREQ_TOLERANCE = 40;

  // Minimum magnitude to consider a tone present
  const DETECT_THRESHOLD = 20;

  // ── DOM Elements ──
  const statusDot  = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const messagesEl = document.getElementById('messages');
  const msgInput   = document.getElementById('msgInput');
  const btnSend    = document.getElementById('btnSend');
  const btnListen  = document.getElementById('btnListen');
  const btnStop    = document.getElementById('btnStop');
  const canvas     = document.getElementById('spectrum');
  const debugLog   = document.getElementById('debugLog');
  const txSpeedEl  = document.getElementById('txSpeed');
  const txDetailEl = document.getElementById('txDetail');
  const rxSpeedEl  = document.getElementById('rxSpeed');
  const rxDetailEl = document.getElementById('rxDetail');
  const ctx        = canvas.getContext('2d');

  // ── State ──
  let audioCtx       = null;
  let analyser       = null;
  let micStream      = null;
  let isListening    = false;
  let isSending      = false;
  let animFrameId    = null;

  // Receiver state machine
  const RX_IDLE      = 0;
  const RX_RECEIVING = 1;
  let rxState        = RX_IDLE;
  let rxBytes        = [];
  const CONFIRM_FRAMES = 3;
  let silenceFrames  = 0;

  // Marker confirmation (ACK / START / STOP)
  let lastMarker     = null;
  let markerConfirm  = 0;

  // Dual-channel data confirmation
  let lastPairA      = null;
  let lastPairB      = null;
  let pairConfirm    = 0;

  // Speed measurement state
  let rxStartTime    = 0;

  // ACK state
  let waitingForAck  = false;
  let ackTimeout     = null;
  let lastSentMsgEl  = null;

  // ── Helpers ──
  function log(msg) {
    const line = document.createElement('div');
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    debugLog.appendChild(line);
    debugLog.scrollTop = debugLog.scrollHeight;
  }

  function setStatus(text, mode) {
    statusText.textContent = text;
    statusDot.className = 'status-dot' + (mode ? ' ' + mode : '');
  }

  function addMessage(text, type) {
    const div = document.createElement('div');
    div.className = 'msg ' + type;
    const body = document.createElement('div');
    body.textContent = text;
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = (type === 'sent' ? 'Sent' : 'Received') + ' at ' +
      new Date().toLocaleTimeString();
    div.appendChild(body);
    div.appendChild(meta);
    messagesEl.appendChild(div);
    messagesEl.scrollTop = messagesEl.scrollHeight;
    return div;
  }

  function formatSpeed(bytes, ms) {
    const seconds = ms / 1000;
    const kbSec = (bytes / 1024) / seconds;
    const bSec = bytes / seconds;
    if (kbSec >= 0.01) {
      return { display: kbSec.toFixed(3) + ' KB/s', detail: bytes + ' B in ' + seconds.toFixed(2) + 's (' + bSec.toFixed(1) + ' B/s)' };
    }
    return { display: bSec.toFixed(1) + ' B/s', detail: bytes + ' B in ' + seconds.toFixed(2) + 's' };
  }

  function crc8(bytes) {
    let crc = 0;
    for (let i = 0; i < bytes.length; i++) {
      crc ^= bytes[i];
      for (let j = 0; j < 8; j++) {
        crc = (crc & 0x80) ? ((crc << 1) ^ 0x07) & 0xFF : (crc << 1) & 0xFF;
      }
    }
    return crc;
  }

  function nibbleToFreqA(n) {
    return FREQ_BASE_A + n * FREQ_STEP;
  }

  function nibbleToFreqB(n) {
    return FREQ_BASE_B + n * FREQ_STEP;
  }

  function freqToBin(freq, fftSize, sampleRate) {
    return Math.round(freq / (sampleRate / fftSize));
  }

  function binToFreq(bin, fftSize, sampleRate) {
    return bin * (sampleRate / fftSize);
  }

  // ── Audio Context Init ──
  function ensureAudioCtx() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    return audioCtx;
  }

  // ── Tone Generation ──
  function playTone(freq, durationMs) {
    return new Promise(resolve => {
      const ctx = ensureAudioCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, ctx.currentTime);

      // Gentle ramp to avoid clicks
      gain.gain.setValueAtTime(0, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.8, ctx.currentTime + 0.005);
      gain.gain.setValueAtTime(0.8, ctx.currentTime + durationMs / 1000 - 0.005);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + durationMs / 1000);

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + durationMs / 1000 + 0.01);

      setTimeout(resolve, durationMs);
    });
  }

  function playDualTone(freqA, freqB, durationMs) {
    return new Promise(resolve => {
      const ctx = ensureAudioCtx();
      const oscA = ctx.createOscillator();
      const oscB = ctx.createOscillator();
      const gain = ctx.createGain();

      oscA.type = 'sine';
      oscA.frequency.setValueAtTime(freqA, ctx.currentTime);
      oscB.type = 'sine';
      oscB.frequency.setValueAtTime(freqB, ctx.currentTime);

      gain.gain.setValueAtTime(0, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.5, ctx.currentTime + 0.005);
      gain.gain.setValueAtTime(0.5, ctx.currentTime + durationMs / 1000 - 0.005);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + durationMs / 1000);

      oscA.connect(gain);
      oscB.connect(gain);
      gain.connect(ctx.destination);

      oscA.start(ctx.currentTime);
      oscB.start(ctx.currentTime);
      oscA.stop(ctx.currentTime + durationMs / 1000 + 0.01);
      oscB.stop(ctx.currentTime + durationMs / 1000 + 0.01);

      setTimeout(resolve, durationMs);
    });
  }

  function silence(durationMs) {
    return new Promise(resolve => setTimeout(resolve, durationMs));
  }

  async function transmitMessage(text) {
    if (isSending) return;
    isSending = true;
    btnSend.disabled = true;
    setStatus('Sending...', 'sending');
    log('TX: "' + text + '"');

    try {
      const txStart = performance.now();

      // START marker
      await playTone(FREQ_START, TONE_MS_MARKER);
      await silence(GAP_MS);

      // Encode each character
      const encoder = new TextEncoder();
      const bytes = encoder.encode(text);

      // Send each data byte as dual tone
      for (let i = 0; i < bytes.length; i++) {
        const byte = bytes[i];
        await playDualTone(
          nibbleToFreqA((byte >> 4) & 0x0F),
          nibbleToFreqB(byte & 0x0F),
          TONE_MS_NIBBLE
        );
        await silence(GAP_MS);
      }

      // Send CRC-8 hash as final byte
      const hash = crc8(bytes);
      await playDualTone(
        nibbleToFreqA((hash >> 4) & 0x0F),
        nibbleToFreqB(hash & 0x0F),
        TONE_MS_NIBBLE
      );
      await silence(GAP_MS);
      log('TX: Sent CRC-8 = 0x' + hash.toString(16).toUpperCase().padStart(2, '0'));

      // STOP marker
      await playTone(FREQ_STOP, TONE_MS_MARKER);

      const txElapsed = performance.now() - txStart;
      const speed = formatSpeed(bytes.length, txElapsed);
      txSpeedEl.textContent = speed.display;
      txDetailEl.textContent = speed.detail;

      lastSentMsgEl = addMessage(text, 'sent');
      log('TX complete — ' + speed.detail);

      // Wait for ACK if listening
      if (isListening) {
        waitingForAck = true;
        lastSentMsgEl.querySelector('.meta').textContent += ' — awaiting ACK...';
        setStatus('Waiting for ACK...', 'sending');
        log('TX: Waiting for ACK...');
        ackTimeout = setTimeout(() => {
          if (waitingForAck) {
            waitingForAck = false;
            if (lastSentMsgEl) {
              const meta = lastSentMsgEl.querySelector('.meta');
              meta.textContent = meta.textContent.replace(' — awaiting ACK...', '') + ' — NO ACK';
              meta.classList.add('no-ack');
              lastSentMsgEl = null;
            }
            log('TX: ACK timeout — no acknowledgment received');
            setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
          }
        }, 5000);
      }
    } catch (e) {
      log('TX error: ' + e.message);
    }

    isSending = false;
    btnSend.disabled = false;
    if (!waitingForAck) {
      setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
    }
  }

  // ── Microphone & Reception ──
  async function startListening() {
    try {
      ensureAudioCtx();

      micStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: SAMPLE_RATE
        }
      });

      const source = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = FFT_SIZE;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);

      isListening = true;
      rxState = RX_IDLE;
      rxBytes = [];
      lastMarker = null;
      markerConfirm = 0;
      lastPairA = null;
      lastPairB = null;
      pairConfirm = 0;
      silenceFrames = 0;

      btnListen.disabled = true;
      btnStop.disabled = false;
      setStatus('Listening', 'listening');
      log('Listening started');

      pollSpectrum();
    } catch (e) {
      log('Mic error: ' + e.message);
      alert('Microphone access denied or unavailable.\n' + e.message);
    }
  }

  function stopListening() {
    isListening = false;
    waitingForAck = false;
    if (ackTimeout) { clearTimeout(ackTimeout); ackTimeout = null; }
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if (animFrameId) {
      cancelAnimationFrame(animFrameId);
      animFrameId = null;
    }
    analyser = null;
    rxState = RX_IDLE;
    rxBytes = [];

    btnListen.disabled = false;
    btnStop.disabled = true;
    setStatus('Idle', '');
    log('Listening stopped');
  }

  // ── Spectrum Analysis & Decoding ──
  function pollSpectrum() {
    if (!isListening || !analyser) return;

    const bufLen = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufLen);
    analyser.getByteFrequencyData(dataArray);

    const sr = audioCtx.sampleRate;

    drawSpectrum(dataArray, bufLen, sr);

    const result = detectTones(dataArray, bufLen, sr);
    processTones(result);

    animFrameId = requestAnimationFrame(pollSpectrum);
  }

  function findPeak(data, bufLen, freqLow, freqHigh, sampleRate) {
    const binLow  = freqToBin(freqLow, FFT_SIZE, sampleRate);
    const binHigh = freqToBin(freqHigh, FFT_SIZE, sampleRate);
    let peakBin = -1, peakVal = 0;
    for (let i = binLow; i <= binHigh && i < bufLen; i++) {
      if (data[i] > peakVal) { peakVal = data[i]; peakBin = i; }
    }
    if (peakVal < DETECT_THRESHOLD) return null;
    return binToFreq(peakBin, FFT_SIZE, sampleRate);
  }

  function detectTones(data, bufLen, sampleRate) {
    let marker = null, chA = null, chB = null;

    // Marker band (17600 – 17950 Hz)
    const mFreq = findPeak(data, bufLen, 17600, 17950, sampleRate);
    if (mFreq !== null) {
      if (Math.abs(mFreq - FREQ_ACK)   < FREQ_TOLERANCE) marker = 'ACK';
      else if (Math.abs(mFreq - FREQ_START) < FREQ_TOLERANCE) marker = 'START';
      else if (Math.abs(mFreq - FREQ_STOP)  < FREQ_TOLERANCE) marker = 'STOP';
    }

    // Channel A – high nibble (18000 – 19500 Hz)
    const aFreq = findPeak(data, bufLen, 17950, 19550, sampleRate);
    if (aFreq !== null) {
      for (let n = 0; n < NUM_NIBBLES; n++) {
        if (Math.abs(aFreq - nibbleToFreqA(n)) < FREQ_TOLERANCE) { chA = n; break; }
      }
    }

    // Channel B – low nibble (16000 – 17500 Hz)
    const bFreq = findPeak(data, bufLen, 15950, 17550, sampleRate);
    if (bFreq !== null) {
      for (let n = 0; n < NUM_NIBBLES; n++) {
        if (Math.abs(bFreq - nibbleToFreqB(n)) < FREQ_TOLERANCE) { chB = n; break; }
      }
    }

    return { marker, chA, chB };
  }

  function processTones({ marker, chA, chB }) {
    const anySignal = (marker !== null || chA !== null || chB !== null);

    if (!anySignal) {
      silenceFrames++;
      markerConfirm = 0; lastMarker = null;
      pairConfirm = 0; lastPairA = null; lastPairB = null;

      if (rxState === RX_RECEIVING && silenceFrames > 120) {
        flushReceived();
      }
      return;
    }

    silenceFrames = 0;

    // ── Marker confirmation ──
    if (marker !== null) {
      if (marker === lastMarker) {
        markerConfirm++;
      } else {
        lastMarker = marker;
        markerConfirm = 1;
      }

      if (markerConfirm === CONFIRM_FRAMES) {
        // ACK is always processed (even while sending)
        if (marker === 'ACK') {
          if (waitingForAck) {
            waitingForAck = false;
            clearTimeout(ackTimeout);
            if (lastSentMsgEl) {
              const meta = lastSentMsgEl.querySelector('.meta');
              meta.textContent = meta.textContent.replace(' — awaiting ACK...', '') + ' — ACK';
              meta.classList.add('acked');
              lastSentMsgEl = null;
            }
            log('TX: ACK received — delivery confirmed!');
            setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');
          }
        } else if (!isSending) {
          if (marker === 'START' && rxState === RX_IDLE) {
            rxState = RX_RECEIVING;
            rxBytes = [];
            rxStartTime = performance.now();
            log('RX: START detected');
            setStatus('Receiving...', 'sending');
          } else if (marker === 'STOP' && rxState === RX_RECEIVING) {
            flushReceived();
          }
        }
        markerConfirm = CONFIRM_FRAMES + 100;
      }
      return; // markers take priority; skip data processing this frame
    }

    // ── Dual-channel data confirmation ──
    if (isSending) return; // prevent self-reception

    if (chA !== null && chB !== null) {
      if (chA === lastPairA && chB === lastPairB) {
        pairConfirm++;
      } else {
        lastPairA = chA;
        lastPairB = chB;
        pairConfirm = 1;
        return;
      }

      if (pairConfirm === CONFIRM_FRAMES) {
        if (rxState === RX_RECEIVING) {
          const byte = (chA << 4) | chB;
          rxBytes.push(byte);
          log('RX byte: 0x' + byte.toString(16).toUpperCase().padStart(2, '0'));
        }
        pairConfirm = CONFIRM_FRAMES + 100;
      }
    } else {
      // partial channel data — reset pair confirmation
      pairConfirm = 0;
      lastPairA = null;
      lastPairB = null;
    }
  }

  function flushReceived() {
    rxState = RX_IDLE;
    setStatus(isListening ? 'Listening' : 'Idle', isListening ? 'listening' : '');

    // Need at least 1 data byte + 1 hash byte
    if (rxBytes.length < 2) {
      log('RX: too few bytes (' + rxBytes.length + '), discarding');
      rxBytes = [];
      return;
    }

    // Last byte = CRC-8 hash, everything before = data
    const receivedHash = rxBytes[rxBytes.length - 1];
    const dataBytes = rxBytes.slice(0, -1);
    const computedHash = crc8(dataBytes);
    const hashMatch = (receivedHash === computedHash);

    if (hashMatch) {
      log('RX: CRC-8 verified (0x' + computedHash.toString(16).toUpperCase().padStart(2, '0') + ')');
    } else {
      log('RX: CRC-8 MISMATCH — received 0x' + receivedHash.toString(16).toUpperCase().padStart(2, '0') +
          ', computed 0x' + computedHash.toString(16).toUpperCase().padStart(2, '0'));
    }

    const rxElapsed = performance.now() - rxStartTime;

    try {
      const decoder = new TextDecoder('utf-8', { fatal: false });
      const text = decoder.decode(new Uint8Array(dataBytes));
      if (text.length > 0) {
        const speed = formatSpeed(dataBytes.length, rxElapsed);
        rxSpeedEl.textContent = speed.display;
        rxDetailEl.textContent = speed.detail;
        addMessage(text + (hashMatch ? '' : ' [CRC FAIL]'), 'received');
        log('RX: "' + text + '" — ' + speed.detail);
      }
    } catch (e) {
      log('RX decode error: ' + e.message);
    }

    rxBytes = [];

    if (hashMatch) {
      sendAck();
    }
  }

  async function sendAck() {
    log('RX: Sending ACK...');
    await silence(500); // pause to let sender's FFT settle after STOP
    await playTone(FREQ_ACK, 300); // longer tone for reliable detection
    log('RX: ACK sent');
  }

  // ── Spectrum Visualizer ──
  function drawSpectrum(data, bufLen, sampleRate) {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    if (canvas.width !== w * dpr || canvas.height !== h * dpr) {
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx.scale(dpr, dpr);
    }

    ctx.clearRect(0, 0, w, h);

    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);

    // Draw full ultrasonic band (15,900 – 19,600 Hz)
    const binLow  = freqToBin(15900, FFT_SIZE, sampleRate);
    const binHigh = freqToBin(19600, FFT_SIZE, sampleRate);
    const numBins = binHigh - binLow + 1;
    const barW = w / numBins;

    for (let i = 0; i < numBins; i++) {
      const bin = binLow + i;
      const val = data[bin] / 255;
      const barH = val * h;

      const freq = binToFreq(bin, FFT_SIZE, sampleRate);
      let color;
      if (freq < 17550) {
        // Channel B (orange)
        color = `hsla(30, 90%, ${30 + val * 40}%, ${0.4 + val * 0.6})`;
      } else if (freq < 18000) {
        // Markers (blue)
        color = `rgba(0, 150, 255, ${0.3 + val * 0.7})`;
      } else {
        // Channel A (green)
        color = `hsla(140, 80%, ${30 + val * 40}%, ${0.4 + val * 0.6})`;
      }

      ctx.fillStyle = color;
      ctx.fillRect(i * barW, h - barH, barW - 0.5, barH);
    }

    // Overlay: detected tone labels
    if (silenceFrames < 3) {
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '11px monospace';
      const labels = [];
      if (lastMarker !== null && markerConfirm >= 1) labels.push(lastMarker);
      if (lastPairA !== null && lastPairB !== null && pairConfirm >= 1)
        labels.push('0x' + ((lastPairA << 4) | lastPairB).toString(16).toUpperCase().padStart(2, '0'));
      if (labels.length) ctx.fillText(labels.join(' | '), 6, 14);
    }
  }

  // ── Event Handlers ──
  btnSend.addEventListener('click', () => {
    const text = msgInput.value.trim();
    if (!text) return;
    msgInput.value = '';
    transmitMessage(text);
  });

  msgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') btnSend.click();
  });

  btnListen.addEventListener('click', startListening);
  btnStop.addEventListener('click', stopListening);

  // Draw empty canvas on load
  function drawEmpty() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.scale(dpr, dpr);
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#334';
    ctx.font = '12px monospace';
    ctx.fillText('Spectrum will appear when listening...', 10, h / 2);
  }

  drawEmpty();
  log('Ready. Click "Start Listening" to begin.');
})();
</script>
</body>
</html>
