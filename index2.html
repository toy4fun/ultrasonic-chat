<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>תקשורת Near‑Ultrasonic בדפדפן – אמינות מוגברת (R=3 + Interleave + Hamming + CRC)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans", "Liberation Sans", sans-serif; margin: 16px; }
    h1 { font-size: 1.35rem; margin: 0 0 0.25rem 0; }
    .note { font-size: 0.95rem; color:#444; background:#f6f8fa; padding:10px; border:1px solid #e6e8eb; border-radius:10px; }
    fieldset { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    legend { padding: 0 6px; color: #444; }
    label { display: inline-block; min-width: 9em; }
    input[type="number"] { width: 7em; }
    textarea { width: 100%; height: 110px; }
    button { padding: 8px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fafafa; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .ok { color: #0a7f3f; }
    .warn { color: #b35a00; }
    .err { color: #b00020; }
    .muted { color: #666; }
    .small { font-size: 0.9rem; }
    .card { border: 1px solid #eee; border-radius: 12px; padding: 10px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
    .k { color:#555; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:0.8rem; border:1px solid #e6e8eb; background:#fff; }
  </style>
</head>
<body>

<h1>תקשורת Near‑Ultrasonic — דגש על אמינות</h1>
<p class="note">
  ערוץ <b>BFSK</b> עם <b>R=3 Repetition</b> + <b>Interleave</b> + <b>Hamming(7,4)</b> + <b>CRC‑8</b>.<br>
  ברירת מחדל: <b>18.5/19.5 kHz</b>, <b>משך סמל 15ms</b>, <b>Preamble ×64</b>.<br>
  <span id="secureCtx" class="pill">בדיקת Secure Context…</span>
</p>

<div class="grid">
  <div class="card">
    <fieldset>
      <legend>שידור (Tx)</legend>
      <div class="row">
        <label for="txText">טקסט לשידור:</label>
      </div>
      <textarea id="txText" placeholder="כתוב טקסט קצר (הודעות/מזהים). נסה תחילה 10–30 תווים."></textarea>

      <div class="row">
        <label>תדר 0 (Hz):</label>
        <input id="f0" type="number" value="18500" min="15000" max="20000" step="10">
        <label>תדר 1 (Hz):</label>
        <input id="f1" type="number" value="19500" min="15000" max="21000" step="10">
      </div>
      <div class="row">
        <label>משך סמל (ms):</label>
        <input id="symMs" type="number" value="15" min="8" max="40" step="1">
        <span class="small k">≈ קצב סמל = 1000 / ms (לפני תקורה ו‑R=3)</span>
      </div>
      <div class="row">
        <label>ווליום:</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6">
        <span id="volVal" class="mono">0.60</span>
      </div>
      <div class="row">
        <button id="btnTx">שדר</button>
        <button id="btnStopTx" disabled>עצור שידור</button>
      </div>
      <div id="txStatus" class="small muted">מוכן לשידור.</div>
    </fieldset>
  </div>

  <div class="card">
    <fieldset>
      <legend>קליטה (Rx)</legend>
      <div class="row">
        <label>תדר 0/1 (Hz):</label>
        <input id="rxF0" type="number" value="18500" min="15000" max="20000" step="10">
        <input id="rxF1" type="number" value="19500" min="15000" max="21000" step="10">
      </div>
      <div class="row">
        <label>משך סמל (ms):</label>
        <input id="rxSymMs" type="number" value="15" min="8" max="40" step="1">
      </div>
      <div class="row">
        <button id="btnRx">התחל קליטה</button>
        <button id="btnStopRx" disabled>עצור קליטה</button>
      </div>
      <div id="rxStatus" class="small muted">המיקרופון ממתין להתחלה…</div>
      <div class="small">
        <strong>תוצאה:</strong>
        <div id="rxOutput" class="mono"></div>
      </div>
    </fieldset>
  </div>
</div>

<fieldset>
  <legend>לוג</legend>
  <pre id="log" class="mono small" style="white-space:pre-wrap;max-height:260px;overflow:auto;background:#fafafa;padding:10px;border-radius:8px;border:1px solid #eee;"></pre>
</fieldset>

<script>
/* ===================== עזרי לוג + Secure Context ===================== */
const logEl = document.getElementById('log');
const secureEl = document.getElementById('secureCtx');
(function(){
  const isFile = location.protocol === 'file:';
  const ok = window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if (isFile) {
    secureEl.textContent = 'נפתח כ- file:// — יש להגיש דרך שרת מקומי (ראו לוג)';
    secureEl.className = 'pill err';
    console.warn('פתחו דרך שרת: python3 -m http.server 8000 ואז http://localhost:8000');
  } else if (ok) {
    secureEl.textContent = 'Secure/Local Context — תקין';
    secureEl.className = 'pill ok';
  } else {
    secureEl.textContent = 'אזהרה: הקשר לא מאובטח';
    secureEl.className = 'pill warn';
  }
})();
function log(msg, cls='') {
  const line = document.createElement('div');
  if (cls) line.className = cls;
  line.textContent = msg;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}

/* ===================== קידוד/פענוח ופריימינג ===================== */
// פרמטרי אמינות
const REP_FACTOR = 3;       // R=3 repetition
const INTERLEAVE_N = 7;     // interleaver קצר

/* UTF-8 <-> Bytes */
function textToBytes(str) { return new TextEncoder().encode(str); }
function bytesToText(bytes) { try { return new TextDecoder().decode(bytes); } catch { return '[Decoding error]'; } }

/* CRC-8 (פולינום 0x07, init=0x00) */
function crc8(bytes) {
  let crc = 0x00;
  for (let b of bytes) {
    crc ^= b;
    for (let i = 0; i < 8; i++) { crc = (crc & 0x80) ? ((crc << 1) ^ 0x07) : (crc << 1); crc &= 0xFF; }
  }
  return crc & 0xFF;
}

/* Hamming(7,4) */
function hamming74EncodeNibble(n) {
  const d1=(n>>3)&1, d2=(n>>2)&1, d3=(n>>1)&1, d4=n&1;
  const p1=(d1^d2^d4)&1, p2=(d1^d3^d4)&1, p3=(d2^d3^d4)&1;
  return [p1,p2,d1,p3,d2,d3,d4];
}
function hamming74Decode7(bits7) {
  const [b1,b2,b3,b4,b5,b6,b7]=bits7;
  const s1=b1^b3^b5^b7, s2=b2^b3^b6^b7, s3=b4^b5^b6^b7; // 3-bit syndrome
  const syndrome=(s3<<2)|(s2<<1)|s1;
  let corrected=[b1,b2,b3,b4,b5,b6,b7];
  if (syndrome!==0 && syndrome>=1 && syndrome<=7) corrected[syndrome-1]^=1;
  const d1=corrected[2], d2=corrected[4], d3=corrected[5], d4=corrected[6];
  const nibble=(d1<<3)|(d2<<2)|(d3<<1)|d4;
  return { nibble, hadError: syndrome!==0 };
}
function bytesToHammingBits(bytes){
  const bits=[]; for(let b of bytes){ const hi=(b>>4)&0xF, lo=b&0xF; hamming74EncodeNibble(hi).forEach(v=>bits.push(v)); hamming74EncodeNibble(lo).forEach(v=>bits.push(v)); } return bits;
}
function hammingBitsToBytes(bits){
  const out=[]; let i=0; const errStats={corrected:0,blocks:0};
  while(i+14<=bits.length){ const hi=hamming74Decode7(bits.slice(i,i+7)); i+=7; const lo=hamming74Decode7(bits.slice(i,i+7)); i+=7; if(hi.hadError)errStats.corrected++; if(lo.hadError)errStats.corrected++; errStats.blocks+=2; out.push(((hi.nibble<<4)|lo.nibble)&0xFF); }
  return { bytes:new Uint8Array(out), errStats };
}

/* Interleave/Deinterleave */
function interleave(bits, N=INTERLEAVE_N){
  const out=new Array(bits.length); const rows=N, cols=Math.ceil(bits.length/rows);
  const grid=Array.from({length:rows},()=>[]);
  for(let i=0;i<bits.length;i++) grid[i%rows].push(bits[i]);
  let k=0; for(let c=0;c<cols;c++){ for(let r=0;r<rows;r++){ if(grid[r][c]!==undefined) out[k++]=grid[r][c]; } }
  return out;
}
function deinterleave(bits, N=INTERLEAVE_N){
  const rows=N, cols=Math.ceil(bits.length/rows); const grid=Array.from({length:rows},()=>new Array(cols).fill(undefined));
  let k=0; for(let c=0;c<cols;c++){ for(let r=0;r<rows;r++){ if(k<bits.length) grid[r][c]=bits[k++]; } }
  const out=[]; for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ const v=grid[r][c]; if(v!==undefined) out.push(v); } }
  return out;
}

/* Repetition coding R=3 */
function repeatBits(bits, R=REP_FACTOR){ const out=[]; for(const b of bits){ for(let i=0;i<R;i++) out.push(b);} return out; }
function majorityDecodeBits(bits, R=REP_FACTOR){ if(R<=1) return bits.slice(); const out=[]; for(let i=0;i<bits.length;i+=R){ let ones=0,zeros=0; for(let j=0;j<R && i+j<bits.length;j++){ bits[i+j]?ones++:zeros++; } out.push(ones>=zeros?1:0);} return out; }

/* פריימינג */
const PREAMBLE_BITS = Array.from({length:64}, (_,i)=> i%2?0:1); // 1010… ×64
const START_MARKER = [1,1,1,1,0,0,0,0];
const END_MARKER   = [0,0,0,0,1,1,1,1];

function makeFrameFromText(text){
  const payload=textToBytes(text);
  const crc=crc8(payload);
  const withCrc=new Uint8Array([...payload, crc]);
  const ham=bytesToHammingBits(withCrc);
  const inter=interleave(ham, INTERLEAVE_N);
  const rep=repeatBits(inter, REP_FACTOR);
  return [...PREAMBLE_BITS, ...START_MARKER, ...rep, ...END_MARKER];
}

function parseFrameBits(allBits){
  const startSeq=START_MARKER.join(''); const endSeq=END_MARKER.join(''); const bitStr=allBits.join('');
  const sIdx=bitStr.indexOf(startSeq); const eIdx=bitStr.indexOf(endSeq, sIdx>-1? sIdx+startSeq.length : 0);
  if(sIdx===-1||eIdx===-1) return {ok:false, reason:'לא נמצא START/END'};

  const payloadBits=allBits.slice(sIdx+START_MARKER.length, eIdx);
  const maj=majorityDecodeBits(payloadBits, REP_FACTOR);
  const deint=deinterleave(maj, INTERLEAVE_N);
  const { bytes, errStats } = hammingBitsToBytes(deint);
  if(bytes.length<1) return {ok:false, reason:'מטען קצר מדי'};
  const data=bytes.slice(0, bytes.length-1); const crcRx=bytes[bytes.length-1]; const crcCalc=crc8(data);
  if(crcCalc!==crcRx) return {ok:false, reason:'CRC שגוי', data, errStats, crcCalc, crcRx};
  return {ok:true, text:bytesToText(data), errStats};
}

/* ===================== שידור (Tx) ===================== */
let audioCtx; let txSrcNode=null; let txGain=null;
const txStatus=document.getElementById('txStatus');
const btnTx=document.getElementById('btnTx');
const btnStopTx=document.getElementById('btnStopTx');
const f0El=document.getElementById('f0');
const f1El=document.getElementById('f1');
const symMsEl=document.getElementById('symMs');
const volEl=document.getElementById('volume');
const volValEl=document.getElementById('volVal');

volEl.addEventListener('input', ()=> volValEl.textContent=(+volEl.value).toFixed(2));

async function ensureAudioCtx(){ if(!audioCtx){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } if(audioCtx.state==='suspended') await audioCtx.resume(); return audioCtx; }

function synthesizeBFSKBitsToBuffer(bits, f0, f1, symSec, sampleRate){
  const totalSamples=Math.floor(bits.length*symSec*sampleRate); const buf=new Float32Array(totalSamples); const twoPi=2*Math.PI;
  let phase0=0, phase1=0; const symSamples=Math.floor(symSec*sampleRate); const fadeSamples=Math.min(Math.floor(0.002*sampleRate), Math.floor(symSamples/6));
  let idx=0; for(let b of bits){ const f=b?f1:f0; const phaseStart=b?phase1:phase0; for(let n=0;n<symSamples && idx<totalSamples;n++,idx++){ const t=n/sampleRate; const val=Math.sin(twoPi*f*t + phaseStart); const fadeIn=n<fadeSamples? n/fadeSamples : 1; const fadeOut=n>(symSamples-fadeSamples)? (symSamples-n)/fadeSamples : 1; const w=Math.min(fadeIn, fadeOut); buf[idx]=val*w; } const phaseAdvance=twoPi*f*(symSamples/sampleRate); if(b) phase1=(phaseStart+phaseAdvance)%(twoPi); else phase0=(phaseStart+phaseAdvance)%(twoPi); }
  return buf;
}

async function startTx(){
  const text=document.getElementById('txText').value.trim(); if(!text) return alert('נא להקליד טקסט לשידור.');
  const f0=+f0El.value, f1=+f1El.value; const symMs=+symMsEl.value; const symSec=symMs/1000;
  const frameBits=makeFrameFromText(text); const ctx=await ensureAudioCtx();
  const pcm=synthesizeBFSKBitsToBuffer(frameBits, f0, f1, symSec, ctx.sampleRate);
  const audioBuffer=ctx.createBuffer(1, pcm.length, ctx.sampleRate); audioBuffer.getChannelData(0).set(pcm);
  txSrcNode=ctx.createBufferSource(); txGain=ctx.createGain(); txGain.gain.value=+volEl.value;
  txSrcNode.buffer=audioBuffer; txSrcNode.connect(txGain).connect(ctx.destination);
  txSrcNode.onended=()=>{ btnTx.disabled=false; btnStopTx.disabled=true; txStatus.textContent='השידור הסתיים.'; log('Tx: הסתיים','ok'); };
  btnTx.disabled=true; btnStopTx.disabled=false; const bitRate=(1/symSec).toFixed(0);
  txStatus.innerHTML=`משדר... אורך: ${frameBits.length} ביט (~${Math.round(frameBits.length/8)} בתים כולל תקורה, כולל R=${REP_FACTOR}), קצב סמלים ≈ <b>${bitRate} sps</b>`;
  log(`Tx: מתחיל שידור (${text.length} תווים, ${frameBits.length} ביט, sym=${symMs}ms)`, 'k');
  txSrcNode.start();
}
function stopTx(){ try{ txSrcNode && txSrcNode.stop(); }catch{} btnTx.disabled=false; btnStopTx.disabled=true; }
btnTx.addEventListener('click', startTx); btnStopTx.addEventListener('click', stopTx);

/* ===================== קליטה (Rx) ===================== */
const btnRx=document.getElementById('btnRx');
const btnStopRx=document.getElementById('btnStopRx');
const rxStatus=document.getElementById('rxStatus');
const rxOutput=document.getElementById('rxOutput');
const rxF0El=document.getElementById('rxF0');
const rxF1El=document.getElementById('rxF1');
const rxSymMsEl=document.getElementById('rxSymMs');
let micStream=null; let rxNode=null; let rxPort=null; let rxBitsBuffer=[]; let rxSyncBuffer=[];

async function startRx(){
  const ctx=await ensureAudioCtx();
  if(!ctx.audioWorklet){ alert('AudioWorklet לא נתמך בדפדפן זה. נסה Chrome/Edge/Firefox עדכני.'); return; }
  // טעינת ה-Worklet בבטיחות
  try{
    if(!workletAdded){ await ctx.audioWorklet.addModule(workletURL); workletAdded=true; log('Rx: AudioWorklet נטען בהצלחה','ok'); }
  }catch(e){ console.error(e); log('Rx: כשל בטעינת AudioWorklet — אל תפתח כ-file://. יש להגיש דרך שרת מקומי (python -m http.server).','err'); alert('טעינת AudioWorklet נכשלה:
'+(e&&e.message?e.message:e)+'

פתח את הקובץ דרך שרת (למשל python -m http.server) ונסה שוב.'); return; }

  try{ micStream=await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }, video:false }); }
  catch(e){ alert('לא ניתן לקבל גישה למיקרופון: '+e.message); return; }

  const src=ctx.createMediaStreamSource(micStream);
  const f0=+rxF0El.value, f1=+rxF1El.value; const symSec=(+rxSymMsEl.value)/1000;
  rxNode=new AudioWorkletNode(ctx,'ultra-rx',{ processorOptions:{ sampleRate:ctx.sampleRate, f0, f1, symSec } });
  rxPort=rxNode.port;
  rxPort.onmessage=(ev)=>{ const {type,data}=ev.data||{}; if(type==='bits'){ for(let b of data) pushRxBit(b); } };
  src.connect(rxNode); // לא מחברים ל-destination – שקט
  btnRx.disabled=true; btnStopRx.disabled=false; rxStatus.textContent=`קולט… f0=${f0}Hz f1=${f1}Hz, סמל=${(symSec*1000).toFixed(1)}ms`;
  rxOutput.textContent=''; log('Rx: התחיל','k');
}
function stopRx(){ try{ rxNode&&rxNode.disconnect(); }catch{} try{ micStream&&micStream.getTracks().forEach(t=>t.stop()); }catch{} btnRx.disabled=false; btnStopRx.disabled=true; rxStatus.textContent='הופסקה הקליטה.'; log('Rx: הופסק','warn'); }
btnRx.addEventListener('click', startRx); btnStopRx.addEventListener('click', stopRx);

function pushRxBit(bit){
  rxSyncBuffer.push(bit); if(rxSyncBuffer.length>128) rxSyncBuffer.shift();
  if(rxBitsBuffer.length===0){
    if(rxSyncBuffer.length>=64){ let altOk=true; for(let i=0;i<64;i++){ const expected=i%2?0:1; if(rxSyncBuffer[rxSyncBuffer.length-64+i]!==expected){ altOk=false; break; } }
      if(altOk){ log('Rx: זוהה PREAMBLE (×64), מתחיל איסוף פריים','ok'); rxBitsBuffer=[]; }
    }
  }
  if(rxSyncBuffer.length>=64 || rxBitsBuffer.length>0){
    rxBitsBuffer.push(bit);
    if(rxBitsBuffer.length >= 64 + 8 + REP_FACTOR*INTERLEAVE_N*14 /* הערכה מינימלית */){
      const res=tryParseFrames(rxBitsBuffer);
      if(res && res.ok){ rxOutput.textContent=res.text; rxStatus.innerHTML=`נקלט בהצלחה. <span class="ok">CRC תקין</span> (תוקנו ${res.errStats.corrected}/${res.errStats.blocks} בלוקים)`; log(`Rx: טקסט נתקבל: "${res.text}"`,'ok'); rxBitsBuffer=[]; rxSyncBuffer=[]; }
    }
    if(rxBitsBuffer.length>40000){ rxBitsBuffer=[]; log('Rx: ניקוי באפר ארוך','warn'); }
  }
}
function tryParseFrames(bits){ for(let offset=0; offset<12; offset++){ const slice=bits.slice(offset); const parsed=parseFrameBits(slice); if(parsed.ok) return parsed; } return null; }

/* ============== AudioWorklet: Goertzel BFSK עם Normalization ============== */
const workletCode = `
class UltraRxProcessor extends AudioWorkletProcessor {
  constructor(options){
    super();
    const opt = options.processorOptions || {};
    this.fs = opt.sampleRate || sampleRate;
    this.f0 = opt.f0 || 18500;
    this.f1 = opt.f1 || 19500;
    this.symSec = opt.symSec || 0.015;
    this.symbolSamples = Math.floor(this.fs * this.symSec);
    this.buf = new Float32Array(0);
    this.coeff0 = 2 * Math.cos(2*Math.PI*this.f0/this.fs);
    this.coeff1 = 2 * Math.cos(2*Math.PI*this.f1/this.fs);
  }
  goertzelPower(arr, coeff){ let s0=0,s1=0,s2=0; for(let i=0;i<arr.length;i++){ s0 = arr[i] + coeff*s1 - s2; s2=s1; s1=s0; } return (s1*s1 + s2*s2 - coeff*s1*s2); }
  process(inputs){
    const input=inputs[0]; if(!input || input.length===0 || input[0].length===0) return true; const ch0=input[0];
    let tmp=new Float32Array(this.buf.length + ch0.length); tmp.set(this.buf,0); tmp.set(ch0,this.buf.length); this.buf=tmp;
    const outBits=[]; const eps=1e-12;
    while(this.buf.length >= this.symbolSamples){
      const frame=this.buf.slice(0, this.symbolSamples);
      // DC remove
      let mean=0; for(let i=0;i<frame.length;i++) mean+=frame[i]; mean/=frame.length; for(let i=0;i<frame.length;i++) frame[i]-=mean;
      // RMS normalize
      let rms=0; for(let i=0;i<frame.length;i++) rms += frame[i]*frame[i]; rms = Math.sqrt(rms/frame.length) + 1e-9; for(let i=0;i<frame.length;i++) frame[i]/=rms;
      const p0=this.goertzelPower(frame, this.coeff0); const p1=this.goertzelPower(frame, this.coeff1);
      const ratio=(p1+eps)/(p0+eps);
      const bit = (ratio>1) ? 1 : 0; // החלטה פשוטה; האמינות נשענת על R=3 + Hamming + CRC
      outBits.push(bit);
      this.buf = this.buf.slice(this.symbolSamples);
    }
    if(outBits.length>0) this.port.postMessage({type:'bits', data: outBits});
    return true;
  }
}
registerProcessor('ultra-rx', UltraRxProcessor);
`;
const workletBlob = new Blob([workletCode], {type:'application/javascript'});
const workletURL = URL.createObjectURL(workletBlob);
let workletAdded = false;
</script>

</body>
</html>
